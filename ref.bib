@misc{zeng2024flightllm,
    title={FlightLLM: Efficient Large Language Model Inference with a Complete Mapping Flow on FPGAs}, 
    author={Shulin Zeng and Jun Liu and Guohao Dai and Xinhao Yang and Tianyu Fu and Hongyi Wang and Wenheng Ma and Hanbo Sun and Shiyao Li and Zixiao Huang and Yadong Dai and Jintao Li and Zehao Wang and Ruoyu Zhang and Kairui Wen and Xuefei Ning and Yu Wang},
    year={2024},
    eprint={2401.03868},
    archivePrefix={arXiv},
    primaryClass={cs.AR}
}
@inproceedings{rpython,
 	author = {Ancona, Davide and Ancona, Massimo and Cuni, Antonio and Matsakis, Nicholas D.},
 	title = {RPython: a step towards reconciling dynamically and statically typed OO languages},
 	booktitle = {DLS '07: Proceedings of the 2007 symposium on Dynamic languages},
 	year = {2007},
 	isbn = {978-1-59593-868-8},
 	pages = {53--64},
 	location = {Montreal, Quebec, Canada},
 	doi = {http://doi.acm.org/10.1145/1297081.1297091},
 	publisher = {ACM},
 	address = {New York, NY, USA},
}
@inproceedings{pypy1,
author = {Bolz, Carl Friedrich and Cuni, Antonio and Fijalkowski, Maciej and Rigo, Armin},
title = {Tracing the meta-level: PyPy's tracing JIT compiler},
year = {2009},
isbn = {9781605585413},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1565824.1565827},
doi = {10.1145/1565824.1565827},
abstract = {We attempt to apply the technique of Tracing JIT Compilers in the context of the PyPy project, i.e., to programs that are interpreters for some dynamic languages, including Python. Tracing JIT compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing JIT to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing JIT compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two kinds of hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two PyPy interpreters: one is a small example, and the other one is the full Python interpreter.},
booktitle = {Proceedings of the 4th Workshop on the Implementation, Compilation, Optimization of Object-Oriented Languages and Programming Systems},
pages = {18–25},
numpages = {8},
location = {Genova, Italy},
series = {ICOOOLPS '09}
}
@misc{izawa2022threaded,
      title={Threaded Code Generation with a Meta-Tracing JIT Compiler}, 
      author={Yusuke Izawa and Hidehiko Masuhara and Carl Friedrich Bolz-Tereick and Youyou Cong},
      year={2022},
      eprint={2106.12496},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}
@inproceedings{pypy2,
 author = {Rigo, Armin and Pedroni, Samuele},
 title = {PyPy's approach to virtual machine construction},
 booktitle = {OOPSLA '06: Companion to the 21st ACM SIGPLAN symposium on Object-oriented programming systems, languages, and applications},
 year = {2006},
 isbn = {1-59593-491-X},
 pages = {944--953},
 location = {Portland, Oregon, USA},
 doi = {http://doi.acm.org/10.1145/1176617.1176753},
 publisher = {ACM},
 address = {New York, NY, USA},
 }
@Article{harris2020array,
 title         = {Array programming with {NumPy}},
 author        = {Charles R. Harris and K. Jarrod Millman and St{\'{e}}fan J.
                 van der Walt and Ralf Gommers and Pauli Virtanen and David
                 Cournapeau and Eric Wieser and Julian Taylor and Sebastian
                 Berg and Nathaniel J. Smith and Robert Kern and Matti Picus
                 and Stephan Hoyer and Marten H. van Kerkwijk and Matthew
                 Brett and Allan Haldane and Jaime Fern{\'{a}}ndez del
                 R{\'{i}}o and Mark Wiebe and Pearu Peterson and Pierre
                 G{\'{e}}rard-Marchant and Kevin Sheppard and Tyler Reddy and
                 Warren Weckesser and Hameer Abbasi and Christoph Gohlke and
                 Travis E. Oliphant},
 year          = {2020},
 month         = sep,
 journal       = {Nature},
 volume        = {585},
 number        = {7825},
 pages         = {357--362},
 doi           = {10.1038/s41586-020-2649-2},
 publisher     = {Springer Science and Business Media {LLC}},
 url           = {https://doi.org/10.1038/s41586-020-2649-2}
}
@ARTICLE{cython,
  author={Behnel, Stefan and Bradshaw, Robert and Citro, Craig and Dalcin, Lisandro and Seljebotn, Dag Sverre and Smith, Kurt},
  journal={Computing in Science & Engineering}, 
  title={Cython: The Best of Both Worlds}, 
  year={2011},
  volume={13},
  number={2},
  pages={31-39},
  keywords={Sparse matrices;Runtime;Syntactics;Computer programs;Programming;Python;Cython;numerics;scientific computing},
  doi={10.1109/MCSE.2010.118}}
@INPROCEEDINGS{pypy3,
  author={During, B.},
  booktitle={AGILE 2006 (AGILE'06)}, 
  title={Trouble in paradise: the open source project PyPy, EU-funding and agile practices}, 
  year={2006},
  volume={},
  number={},
  pages={11 pp.-231},
  keywords={Collaborative work;Open source software;Project management;Programming;Collaborative software;Testing},
  doi={10.1109/AGILE.2006.58}}
@article{jit,
author = {Phogat, Sandeep},
year = {2013},
month = {07},
pages = {},
title = {INTRODUCTION TO JIT: A REVIEW},
volume = {2},
journal = {International Journal of Latest Research in Science and Technology}
}
@article{hlsintro,
author = {Coussy, Philippe and Gajski, Daniel and Meredith, Michael and Takach, Andres},
year = {2009},
month = {09},
pages = {8 - 17},
title = {An Introduction to High-Level Synthesis},
volume = {26},
journal = {Design & Test of Computers, IEEE},
doi = {10.1109/MDT.2009.69}
}
@INPROCEEDINGS{dsl1,
  author={George, Nithin and Lee, HyoukJoong and Novo, David and Rompf, Tiark and Brown, Kevin J. and Sujeeth, Arvind K. and Odersky, Martin and Olukotun, Kunle and Ienne, Paolo},
  booktitle={2014 24th International Conference on Field Programmable Logic and Applications (FPL)}, 
  title={Hardware system synthesis from Domain-Specific Languages}, 
  year={2014},
  volume={},
  number={},
  pages={1-8},
  keywords={Hardware;Kernel;Optimization;DSL;Field programmable gate arrays;Data structures;Parallel processing},
  doi={10.1109/FPL.2014.6927454}}
@article{halide,
author = {Ragan-Kelley, Jonathan and Adams, Andrew and Sharlet, Dillon and Barnes, Connelly and Paris, Sylvain and Levoy, Marc and Amarasinghe, Saman and Durand, Fr\'{e}do},
title = {Halide: decoupling algorithms from schedules for high-performance image processing},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {61},
number = {1},
issn = {0001-0782},
url = {https://doi.org/10.1145/3150211},
doi = {10.1145/3150211},
abstract = {Writing high-performance code on modern machines requires not just locally optimizing inner loops, but globally reorganizing computations to exploit parallelism and locality---doing things such as tiling and blocking whole pipelines to fit in cache. This is especially true for image processing pipelines, where individual stages do much too little work to amortize the cost of loading and storing results to and from off-chip memory. As a result, the performance difference between a naive implementation of a pipeline and one globally optimized for parallelism and locality is often an order of magnitude. However, using existing programming tools, writing high-performance image processing code requires sacrificing simplicity, portability, and modularity. We argue that this is because traditional programming models conflate the computations defining the algorithm with decisions about intermediate storage and the order of computation, which we call the schedule.We propose a new programming language for image processing pipelines, called Halide, that separates the algorithm from its schedule. Programmers can change the schedule to express many possible organizations of a single algorithm. The Halide compiler then synthesizes a globally combined loop nest for an entire algorithm, given a schedule. Halide models a space of schedules which is expressive enough to describe organizations that match or outperform state-of-the-art hand-written implementations of many computational photography and computer vision algorithms. Its model is simple enough to do so often in only a few lines of code, and small changes generate efficient implementations for x86, ARM, Graphics Processors (GPUs), and specialized image processors, all from a single algorithm.Halide has been public and open source for over four years, during which it has been used by hundreds of programmers to deploy code to tens of thousands of servers and hundreds of millions of phones, processing billions of images every day.},
journal = {Commun. ACM},
month = {dec},
pages = {106–115},
numpages = {10}
}