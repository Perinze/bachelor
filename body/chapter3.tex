\section{基于XLS的Python高层综合编译器}

本章详细介绍基于XLS的Python高层综合编译器的系统架构以及实现原理，
包括三个主要部分：编译器前端xlspy、基于XLS优化器的代码变换以及浮点数支持。
xlspy是高层综合编译器的前端部分，
能够对Python代码分析并生成XLS中间表示。
基于XLS优化器的代码变换是一种对XLS中间表示做展开与修改的方法，
可以用于类型展开等用途。
最后，我们介绍如何基于代码变换为XLS中间表示添加浮点数支持，
用于生成浮点数运算的寄存器传输级代码。

\subsection{编译器前端xlspy}

本节详细介绍编译器前端xlspy。
xlspy是整个高层综合流程的开始，
它读取硬件设计的Python代码，
进行语法分析和类型推断等工作，
并生成可优化的XLS中间表示代码。
让我们用一个例子引出对xlspy的介绍。

\begin{figure}[h]
    \begin{lstlisting}[language=Python,frame=single]
        def top(a: int, b: int, f: bool):
            c = a + b
            if f:
                c = a * b
            return c
    \end{lstlisting}
    \caption{编译器输入示例代码}
    \label{code.1}
\end{figure}

如图\ref{code.1}所示，
xlspy接受的Python代码需要至少一个函数作为顶层函数，
这里即为top函数。
我们可以注意到函数参数包含类型标注，
在这些参数类型确定的基础下，
top函数体的所有变量的类型都可以推导出来，
包括top函数的返回值。
xlspy支持一个可以进行硬件设计的完整的Python语言子集，
为了使硬件描述Python代码可读性更高，
for-else之类容易令人感到迷惑的语法不被支持。

要进行类型推导，
首先需要获取代码的AST，
并记录top函数的参数类型，
最后开始遍历函数体。
对于每个赋值语句，
我们可以计算出右侧表达式的类型，
并将这个类型记录为被赋值变量的类型。
新的计算总是会依赖于已有的计算结果，
而已有的计算可以推导出类型，
所以新的计算的类型也是可以确定的。

\subsubsection{类型支持}

Python是一门动态类型语言，
在解释器执行的情况下，
类型信息是在运行时才得知的。
相反，HDL是非常典型的静态类型语言，
因为硬件结构在综合阶段就需要完全确定。
Python因为其弱类型带来的灵活性被广泛应用，
但对弱类型的Python进行静态分析是一件自相矛盾的事情。
为了解决这个问题，
xlspy将类型的支持范围交给用户自行配置，
并支持用户指定的有限种类型下的动态类型。

Verilog HDL所支持的类型仅有两个维度，
首先类型是wire还是reg类型，
其次是位宽。
作为生成HDL的工具，
xlspy支持的所有类型必须在编译时期便可推断出对应的HDL类型。
所以定义格式的原始方式是定义其位宽
（wire或者reg需要推导）。
另一方面，
大多数开发者习惯于使用int, double一类的类型名，
所以xlspy提供了常见类型名作为别名，
并允许用户自行添加别名。

xlspy支持在类型配置的范围内支持动态类型。
动态类型是Python重要的语言特性。
要在运行时支持多种类型，
需要硬件电路在计算时保留数据的类型信息。
xlspy在生成XLS中间表示前会对类型做一次静态分析，
尽可能多地推导类型信息。
对于无法在编译期推导出类型的变量，
xlspy会为源代码逻辑生成多种类型的硬件逻辑，
分别适用于变量为各种类型时的情况。
在硬件进行实际计算时，
根据运行时的类型信息，
不同类型的数据会有不同的数据通路。

\begin{figure}[h]
    \begin{lstlisting}[language=Python,frame=single]
        def add3(x):
            return x + 3
    \end{lstlisting}
    \caption{动态类型示例代码}
    \label{code.2}
\end{figure}

\begin{figure}[h]
\centering
\includesvg{figure/example2.svg}
\caption{动态类型硬件示意图}
\label{fig.2}
\end{figure}

例如源代码（图\ref{code.2}）和其对应的硬件结构（图\ref{fig.2}），
由于未指定add1的参数类型，
xlspy假定变量x可能为int或float类型，
因此生成两种可能的硬件结构应对可能的输入类型。

\subsubsection{XLS中间表示的生成}

在类型确定的情况下，
我们很容易得知生成硬件的位宽等信息。
但决定硬件行为的关键是硬件的内部结构，
我们需要分析输入代码的语义来得知生成的硬件应该有什么样的结构。

图\ref{fig.1}是代码\ref{code.1}所生成硬件示意图，
在生成的硬件中，
MUX实现了条件分支语句的功能，
以计算结果选择器的形式。
这里需要注意这样的实现方法仅适用于条件分支没有副作用的情况，
即计算过程仅仅产生了计算结果，
没有访问内存的操作。
会出现这样的问题是因为结果选择器需要几个可选结果已经完成了相应的计算，
而CPU在执行if语句时，
并不会执行所有的分支，
而是仅有需要计算的分支才会被执行。
由于本工作不支持生成内存相关的计算，
自然不会有具有副作用，
所以MUX模拟if的行为是可以接受的。

\begin{figure}[h]
\centering
\includesvg{figure/example1.svg}
\caption{硬件示意图}
\label{fig.1}
\end{figure}

图\ref{fig.1}中，所生成的硬件首先分别计算了a + b和a * b两个结果，
分别命名为c.1和mul.2（这也是生成IR中的值的名称），
然后MUX根据f的值选择add.1或是mul.2作为c.2的值，
最后将c.2作为硬件模块的输出。
从c.1与c.2的分离可以看出，
xlspy对于同一个变量名，
可能会生成多个IR值的名称，
这是因为IR实际上是一种树形结构，
每个节点代表一种运算，
由其它节点作为其输入，
而自身作为后续节点的输入。
xlspy在为这些节点命名时候，
会尽量保留输入代码的名称信息，
如c.1代表源代码第一次对c赋值，
c.2代表if语句中对c的赋值。
在源代码没有命名却需要单独生成一个节点的情况时，
会根据节点所做的运算为其命名。